#  操作系统lab0.5+lab1实验报告
##  lab 0.5
#### 本实验中重要知识点：
`gdb调试方法`  `RISCV机器启动流程`
###  练习1: 使用GDB验证启动流程

由于在qemu源代码中宏定义了复位地址**0x1000**，使用gdb调试QEMU模拟的RISC-V计算机加电后，将直接从**0x1000**处开始执行汇编代码
![从0x1000处开始的汇编代码](/graph/1.png)
<br>
***复位地址上的复位代码如下***
<br>
```
auipc t0,0x0     //将 PC 的值加上一个立即数0x0，并将结果存储到一个寄存器中 t0中。
addi  a1,t0,32   //将立即数32加在寄存器t0中，并将结果储存在寄存器a1里
csrr  a0,mhartid //读取特定控制状态寄存器（CSR）的指令，并将结果存储到一个通用寄存器 a0中.
ld    t0,24(t0)  //从内存中加载数据0x80000000的指令，并将结果存储到一个通用寄存器t0中
jr    t0         //跳转到由寄存器指定的地址的指令,即跳转到0x80000000处运行bootloader
```
***跳转到0x80000000后将执行以下汇编代码***
![汇编代码](/graph/2.png)
<br>
```
csrr a6,mhartid    //读取特定控制状态寄存器（CSR）的指令，并将结果存储到一个通用寄存器 a6中.
bgtz a6,0x80000108 //如果 a6 寄存器中的值大于零，程序计数器（PC）的值会被设置为 0x80000108，然后程序会从该地址开始执行。否则，程序会继续执行下一条指令。
auipc  t1,0x0      //将 PC 的值加上一个立即数0x0，并将结果存储到一个寄存器中 t1中。
addi  a1,t0,1032   //将立即数1032加在寄存器t0中，并将结果储存在寄存器a1里
auipc  t1,0x0      //将 PC 的值加上一个立即数0x0，并将结果存储到一个寄存器中 t1中。
addi  t1,t1,-16    //将立即数-16加在寄存器t1中，并将结果储存在寄存器t1里
sd    t1,0(t0)     //t1 寄存器中的值将被存储到内存中地址为 t0 的位置
auipc  t0,0x0      //将 PC 的值加上一个立即数0x0，并将结果存储到一个寄存器中 t0中。
addi  t0,t0,1020   //将立即数1020加在寄存器t0中，并将结果储存在寄存器t0里
ld   t0,0(t0)      //从内存中加载数据0+t0的指令，并将结果存储到一个通用寄存器t0中
······
```
在**0x80200000**处打上断点后运行到**0x80200000**后即开始执行应用程序的第一条指令，进入一个死循环之中

***思考与讨论***
<br>
本实验中未涉及如何将内核镜像**os.bin** 被加载到以物理地址 0x80200000开头的区域上的过程
0x80200000处的代码为**地址相关代码**不可以随意更换代码地址


##  lab 1
#### 本实验中重要知识点：
`内核启动程序入口`  `中断处理`  `上下文切换`
### 练习1：理解内核启动中的程序入口操作
Q:阅读 kern/init/entry.S内容代码，结合操作系统内核启动流程，说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？ tail kern_init 完成了什么操作，目的是什么？

A：`la sp, bootstacktop`: 这条指令是RISCV汇编语言中的一条加载指令，它将 `bootstacktop` 的地址加载到 `sp` 寄存器中。在这里，`sp` 是栈指针，`bootstacktop` 是栈顶地址。这样做的目的是设置栈指针，确保在后续的代码执行中，如果有函数调用或者中断发生，可以使用正确的栈空间。
<br>
`tail kern_init`: 作用是利用尾部调用方式调用函数kern_init，目的是利用尾调用优化代码，在一个函数的最后一条指令中直接调用另一个函数，并且不需要返回到当前函数。这样可以避免创建新的栈帧，减少函数调用的开销和内存的使用。kern_init函数将需要初始化为0的数据分配好内存空间并赋值0，然后利用封装好的输出函数打印一条信息表明操作系统成功启动，最后进入一个死循环

###  练习2：完善中断处理
Q:请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写kern/trap/trap.c函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机。
要求完成问题1提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程和定时器中断中断处理的流程。实现要求的部分代码后，运行整个系统，大约每1秒会输出一次”100 ticks”，输出10行。

完善代码如下：
```
 case IRQ_S_TIMER:
        clock_set_next_event();
	    ticks++;
	    if(ticks==100){
		    print_ticks();
		    num++;
		    ticks=0;
		}
	    if(num==10){
		    sbi_shutdown();
		}
        break;
```
实现过程：每次进入S模式时钟中断令ticks+1，当ticks加至100后在屏幕打印100 ticks，令num+1,同时将ticks清零。当num增加至10后调用sbi_shutdown()关机。
<br>
定时器中断处理流程：<br>
1）配置时钟中断：在启动系统之前，需要对时钟中断进行配置。具体的配置方式取决于使用的硬件平台和操作系统。通常包括设置时钟中断间隔、使能时钟中断、设置中断处理程序等。<br>
2）运行程序：启动系统后，处理器开始执行程序。<br>
3）时钟中断触发：当系统的时钟周期满足配置的时钟中断间隔时，会触发时钟中断信号。<br>
4）异常处理：当时钟中断触发时，处理器会立即停止当前正在执行的指令，并进入异常处理流程。<br>
5）切换到特权级模式：在进入异常处理流程之前，处理器会从当前执行的模式（一般是用户态）切换到特权级模式（一般是 S 态或 M 态）。<br>
6）保存上下文：处理器会保存当前的上下文信息，包括程序计数器（PC）、寄存器状态以及其他必要的寄存器。<br>
7）跳转到中断处理程序：处理器会根据中断向量表或中断处理程序的地址，跳转到预先定义好的中断处理程序。<br>
8）中断处理程序执行：中断处理程序会执行特定的操作，例如更新系统时间、处理定时任务、处理延时操作等。具体的中断处理程序代码由操作系统或开发者定义。<br>
9）恢复上下文：中断处理程序执行完成后，处理器会从保存的上下文信息中恢复现场，包括将之前保存的寄存器状态还原回来。<br>
10）返回到原程序：恢复现场后，处理器会跳转回原来被中断打断的指令，并继续执行程序。<br>
执行结果如下:
![运行结果](/graph/3.png)
如图所示，正常每1秒输出一次100ticks并在输出10行后自动调用sbi.h中的shut_down()函数关机。
### 扩展练习 Challenge1：描述与理解中断流程
Q：描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？SAVE_ALL中寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。

A：	1、`mov a0, sp`将当前的栈指针sp的值复制到寄存器a0中。在RISCV中，a0通常被用作系统调用的参数传递。
<br>
2、`SAVE_ALL`中寄存器保存在栈中的位置由它们的编号决定，从X0到X31。
<br>
3、实际上并不需要。因为对于绝大多数程序来说并没有用到所有寄存器，而只用到了其中的某一部分，所以对于他们中断时只需保存对应寄存器的值即可。但是为了代码的简洁、通用性，我们对所有进程都保存所有寄存器的值。
		
###  扩展练习 Challenge2：理解上下文切换机制
Q：在trapentry.S中汇编代码 csrw sscratch, sp；csrrw s0, sscratch, x0实现了什么操作，目的是什么？save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？<br>
A：1、***csrw sscratch, sp***这条指令将栈指针(sp)的值写入到名为sscratch的CSR中。***csrrw s0, sscratch, x0*** 这条指令将sscratch的值读取到s0寄存器，同时将x0寄存器的值(0)写入到sscratch。在这两个操作中，sscratch通常被用作一个临时寄存器，用于在不同的操作之间保存和恢复状态。<br>
2、在异常处理或系统调用中，stval、scause这些csr里的数据可能包括函数的返回值、寄存器的旧值等，trap恢复时中断处理结束，已经不需要这些值。但在其他地方，可能需要这些值来判断异常的原因，或者决定如何处理异常。因此，在***save all***中保存这些值仍然是有意义的。

### 扩展练习Challenge3：完善异常中断
编程完善在触发一条非法指令异常mret，在 kern/trap/trap.c的异常处理函数中捕获，并对其进行处理，简单输出异常类型和异常指令触发地址，即“Illegal instruction caught at 0x(地址)”，“ebreak caught at 0x（地址）”与“Exception type:Illegal instruction"，“Exception type: breakpoint”。
